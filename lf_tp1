(* TP1 Langages formels

   ATTENTION
   Pour le bon affichage des caractÃ¨res accentuÃ©s, prÃ©cisez que l'encodage par dÃ©faut de votre NAVIGATEUR doit Ãªtre Unicode (UTF-8)

   BUT DU TP

   Manipuler Coq / Gallina

   Se familiariser avec 4 mots-clÃ©s :
      - Definition
      - Definition avec match ... with
      - Inductive
      - Fixpoint
*)


(* DÃ‰FINIR UN OBJET (entier, fonction, etc.) *)
(* Mot-clef "Definition" 
   suivi du nom de l'objet
   suivi de ":" 
   suivi du type de l'objet
   suivi de ":="
   suivi de la valeur de l'objet. *)
Definition a : nat := 3.
Definition b : nat := 6.

(* En Coq on donne TOUJOURS les types. *)

(* EFFECTUER UN CALCUL... dans l'interprÃ©teur *)
(* Directive "Compute" *)
(* RÃ‰SULTAT ATTENDU : 9 *)
Compute (a+b).

(* AFFICHER LE TYPE... dans l'interprÃ©teur *)
(* Directive "Check" *)
Check (a+b).



(* 1) TYPES Ã‰NUMÃ‰RÃ‰S et INDUCTIFS *)


(* Mots-clefs "Inductive" et "|" par cas. 
   C'est la dÃ©finition d'un ensemble inductif, on donne des rÃ¨gles...
   Comme on dÃ©finit un *type* de donnÃ©es, son propre type est Type. *)
Inductive jour : Type :=
  | lundi : jour
  | mardi : jour
  | mercredi : jour
  | jeudi : jour
  | vendredi: jour
  | samedi : jour
  | dimanche : jour.
(* ici uniquement des cas de base *)


(* On peut dÃ©finir une FONCTION jour_suivant sur ce type.
   (jour_suivant e) s'Ã©value en le nom du jour suivant le jour e.
   Elle est rÃ©alisÃ©e suivant *la forme* du paramÃ¨tre, c'est du
   "filtrage" ou "PATTERN MATCHING". C'est le mÃ©canisme le plus
   confortable pour manipuler des structures inductives. *)
(* Mots-clef "match" "with" "end" *)
Definition jour_suivant (j : jour) : jour :=
  match j with
  | lundi => mardi
  | mardi => mercredi
  | mercredi => jeudi
  | jeudi => vendredi
  | vendredi => samedi
  | samedi => dimanche
  | dimanche => lundi
  end.

(* On teste. RÃ‰SULTAT ATTENDU : jeudi *)
Compute (jour_suivant mercredi).


(* EXERCICE *)
(* DÃ©finir la fonction qui retourne le surlendemain d'un jour donnÃ© *)
(* C'est une fonction qui APPLIQUÃ‰E Ã€ un jour, RETOURNE un jour *)
Definition jour_suivant_le_jour_suivant (j : jour) : jour :=
  match j with
  | lundi => mercredi
  | mardi => jeudi
  | mercredi => vendredi
  | jeudi => samedi
  | vendredi => dimanche
  | samedi => lundi
  | dimanche => mardi
  end.
(* On re-teste et on devrait obtenir vendredi*)
Compute (jour_suivant_le_jour_suivant mercredi).
(* Compute (jour_suivant_le_jour_suivant mercredi). *)

Definition surlendemain (j : jour) : jour :=
jour_suivant (jour_suivant j).

Compute (surlendemain lundi).

Theorem t1 : forall j, jour_suivant_le_jour_suivant j = surlendemain j.
Proof.
induction j; auto.
Qed.

(* On peut aussi dÃ©finir les boolÃ©ens... *)
(* Il n'y a que des cas de base et on va les appeler Vrai et Faux *)
Inductive booleens : Type :=
| Vrai : booleens
| Faux : booleens.

(* Ainsi que les fonctions logiques usuelles. *)
(* Le complÃ©mentaire : non. *)
Definition non (a : booleens) : booleens :=
  match a with
  | Vrai => Faux
  | Faux => Vrai
  end.


(* Directive d'affichage de type *)
Check non.

(* Directive d'affichage de valeur *)
Print non.


(* EXERCICE *)
(* DÃ©finir la fonction "et" sur les boolÃ©ens. *)
Definition et (a : booleens) (b : booleens) : booleens :=
  match a with 
  | Faux => Faux
  | Vrai => b
  end.


Definition et' (a : booleens) (b : booleens) : booleens :=
  match a,b with 
  | Vrai, Vrai => Vrai
  | _, _       => Faux
  end.

Definition et'' (a : booleens) (b : booleens) : booleens :=
  match a,b with 
  | Vrai, Vrai => Vrai
  | Vrai, Faux => Faux
  | Faux, Vrai => Faux
  | Faux, Faux => Faux
  end.

(* un petit test, RÃ‰PONSE ATTENDUE : Faux *)
Compute (et Vrai (et Faux Vrai)).
Compute (et' Vrai (et' Faux Vrai)).
Compute (et'' Vrai (et'' Faux Vrai)).

(* EXERCICE *)
(* DÃ©finir la fonction "ou" sur les boolÃ©ens. *)
Definition ou (a : booleens) (b : booleens) : booleens :=
  match a with
  | Vrai
  | Faux => b
  end.

(* RÃ‰PONSE ATTENDUE : Vrai *)
(* Compute (et Vrai (ou Faux Vrai)). *)
Compute (et Vrai (ou Faux Vrai)).

(* Le langage de Coq a bien sÃ»r des boolÃ©ens (dans le type prÃ©dÃ©fini bool),
   ils sont en fait dÃ©finis de la mÃªme faÃ§on que nos booleens. Pour l'instant
   nous allons continuer de travailler avec les nÃ´tres. *)

(* On dÃ©finit maintenant de faÃ§on inductive le type des entiers naturels.
   Un entier naturel est :
   - soit un Ã©lÃ©ment particulier notÃ© Z (pour zÃ©ro, c'est un cas de base ici),
   - soit le successeur d'un entier naturel.
 
   On a bien DEUX CONSTRUCTEURS pour les entiers : ils sont soit de la
   *forme* "Z" soit de la *forme* "Succ d'un entier".
*)
Inductive entiers : Type :=
| Z : entiers
| Succ : entiers -> entiers.

Definition un  := Succ Z.
Definition deux  := Succ un.
Definition trois  := Succ deux.


(* EXERCICE *)
(* DÃ©finir la fonction prÃ©dÃ©cesseur *)
(* C'est une fonction qui APPLIQUÃ‰E Ã€ un entier, RETOURNE un entier *)
(* On considÃ¨re que le prÃ©dÃ©cesseur de quelque chose de la forme Z est... Z *)
(* Le prÃ©dÃ©cesseur de quelque chose de la forme Succ toto est bien sÃ»r toto *)
Definition pred (a : entiers) : entiers :=
  match a with
  | Z => Z
  | Succ x => x
  end.

(* RÃ‰SULTAT ATTENDU :  Succ (Succ Z) *)
(* Compute (pred (Succ (Succ (Succ Z)))).*)
Compute (pred (Succ (Succ (Succ Z)))).
Compute (pred Z).
Compute (pred (Succ Z)).

(* On veut Ã©crire une FONCTION RÃ‰CURSIVE pour ajouter deux entiers.
   Comme la fonction est rÃ©cursive, on utilise le mot-clÃ© Fixpoint (et
   non plus Definition).
   Elle se calcule selon la forme du premier paramÃ¨tre *) 
Fixpoint plus (a : entiers) (b : entiers) : entiers :=
  match a with
  | Z => b
  | Succ n => Succ (plus n b)
  end.

Compute (plus un deux).

(* EXERCICE *)
(* Multiplication
   Elle se calcule selon la forme du premier paramÃ¨tre *)
Fixpoint mult (a : entiers) (b : entiers) : entiers :=
  match a with
  | Z => Z
  | Succ n => (plus b (mult n b))
  end.

(* RÃ‰SULTAT ATTENDU : 9 *)
(* Compute (mult trois trois). *)
Compute (mult trois trois).
Compute (mult un deux).
Compute (mult deux deux).

(* EXERCICE *)
(* DÃ©finir une fonction est_pair, telle que est_pair APPLIQUÃ‰E Ã€ un entier a RETOURNE Vrai si a est pair, Faux sinon. *)
Fixpoint est_pair (a : entiers) : booleens :=
  match a with
  | Z => Vrai
  | Succ Z => Faux
  | Succ (Succ n) => (est_pair n)
  end.

Fixpoint est_pair' (a : entiers) : booleens :=
  match a with
  | Z => Vrai
  | Succ n => non(est_pair' n)
  end.

(* RÃ‰SULTAT ATTENDU : Vrai *)
(* Compute (est_pair deux). *)
Compute (est_pair deux). 
Compute (est_pair' deux). 

(* RÃ‰SULTAT ATTENDU : Faux *)
(* Compute (est_pair trois). *)
Compute (est_pair trois).
Compute (est_pair' trois).
(* ------------------------------------------------------------ *)


(* PrÃ©cÃ©demment, on a dÃ©fini nos boolÃ©ens et nos entiers naturels,
mais ils sont en fait dÃ©jÃ  dÃ©finis dans la bibliothÃ¨que que Coq charge
initialement au dÃ©marrage :

Inductive bool : Set :=
  | true : bool
  | false : bool.

avec les fonctions 

negb (le complÃ©mentaire)
andb (le et, (le min))
orb  (le ou, (le max))



Inductive nat : Set :=
  | O : nat
  | S : nat -> nat.

avec les fonctions usuelles + , - , * , etc.
et les comparaisons :
Nat.eqb pour le test d'Ã©galitÃ©
Nat.ltb pour le test plus petit
Nat.leb pour le test plus petit ou Ã©gal.


CE SONT EUX QU'ON UTILISERA DORÃ‰NAVANT.

 *)

(* ------------------------------------------------------------ *)


(* 2) LISTES D'OBJETS DE TYPE NAT *)


(* On considÃ¨re ici des listes d'objets de type nat. *)

(* On peut dÃ©finir de faÃ§on inductive un type nliste pour les listes d'objets de type nat. 
  Le cas de base est bien sÃ»r la liste vide, l'autre rÃ¨gle de construction applique cons
  Ã  un nat et une liste de l'ensemble inductif pour crÃ©er un nouvel Ã©lÃ©ment de cet ensemble
*)
Inductive nliste : Type :=
  | vide : nliste
  | cons : nat -> nliste -> nliste.

Definition liste0 := vide.
Definition liste1 := cons 1 vide.
Definition liste2 := cons 2 (cons 1 vide).
Definition liste3 := cons 3 (cons 2 (cons 1 vide)).
Definition liste4 := cons 4 (cons 3 (cons 2 (cons 1 vide))).
Print liste0.
Print liste1.
Print liste2.


(* EXERCICE *)
(* Ã‰crire une fonction ajoute: nat -> nliste -> nliste telle que ajoute n l
   retourne une liste correspondant Ã  l'ajout de l'Ã©lÃ©ment n Ã  la liste l.
   C'est bien sÃ»r juste la fonction qui applique cons
*)

(* RÃ‰SULTAT ATTENDU : cons 3 (cons 2 (cons 1 vide)) *)
(* Compute (ajoute 3 liste2). *)


(* EXERCICE *)
(* Ã‰crire une fonction longueur telle que longueur APPLIQUÃ‰E Ã€ l
   RETOURNE le nombre (nat) d'Ã©lÃ©ments de la liste l.  On l'a vue en
   cours.
  C'est bien sÃ»r une fonction qui travaille selon la FORME de l : si
  c'est vide, la longueur vaut zÃ©ro, et si l est de la forme cons n l'
  Ã  vous de jouer.  *)

(* RÃ‰SULTAT ATTENDU : 2 *)
(* Compute (longueur liste2).*)

(* EXERCICE *)
(* Ã‰crire une fonction concat: nliste -> nliste -> nliste telle que concat l l'
   retourne une liste correspondant Ã  l'ajout des Ã©lÃ©ments de l en tÃªte de la liste l'. *)

(* RÃ‰SULTAT ATTENDU : cons 2 (cons 1 (cons 2 (cons 1 vide))) *)
(* Compute (concat liste2 liste2).*)

(* EXERCICE *)
(* Ã‰crire une fonction recherche: nat -> nliste -> booleens telle que recherche n l
   retourne Vrai si un Ã©lÃ©ment n appartient Ã  la liste l et Faux sinon. *)
(* Pour l'Ã©galitÃ© entre Ã©lÃ©ments du type nat, soit on la redÃ©finit, soit on utilise Nat.eqb *)
Require Import Nat.
Check (eqb 3 4).
Compute (eqb 3 4).

(* RÃ‰SULTAT ATTENDU : true *)
(* Compute (recherche 1 liste2).*)

(* RÃ‰SULTAT ATTENDU : false *)
(* Compute (recherche 3 liste2).*)


(* FIN DU TP1 *)

(* ------------------------------------------------------------ *)

(* EXERCICES A FAIRE CHEZ VOUS *)

(* EXERICE *)
(* DÃ©finir une fonction bcompose : f -> g -> h telle que h est la composition des
deux fonctions boolÃ©ens f et g *)

(* Tester bcompose en dÃ©finissant une fonction nonnon : boolÃ©ens -> boolÃ©ens qui
dÃ©finit non o non *)

(* RÃ‰SULTAT ATTENDU : Vrai *)
(* Compute (nonnon Vrai). *)


(* EXERCICE *)
(* DÃ©finir la fonction factorielle sur les entiers *)

(* RÃ‰SULTAT ATTENDU : 24 sous forme de Succ( ... (Succ(Z) ...) *)
(* Compute (factorielle (plus trois un)). *)


(* EXERCICE *)
(* DÃ©finir la fonction moins, soustraction non nÃ©gative sur les entiers *)

(* RÃ‰SULTAT ATTENDU : Succ Z *)
(* Compute (moins deux un).*)

(* RÃ‰SULTAT ATTENDU : Z *)
(* Compute (moins deux trois).*)

(* EXERCICE *)
(* DÃ©finir une fonction inf, tel que inf a b vaut/retourne Vrai si a est
   infÃ©rieur ou Ã©gal Ã  b, Faux sinon. *)

(* RÃ‰SULTAT ATTENDU : Vrai *)
(* Compute (inf trois trois). *)


(* EXERCICE *)
(* DÃ©finir une fonction egal, tel que egal a b donne Vrai si les entiers
   a et b sont Ã©gaux, Faux sinon.*)

(* RÃ‰SULTAT ATTENDU : Vrai *)
(* Compute (egal trois trois). *)

(* RÃ‰SULTAT ATTENDU : Faux *)
(* Compute (egal un trois). *)


(* EXERCICE *)
(* Ã‰crire une fonction miroir: nliste -> nliste, qui
   retourne une liste correspondant Ã  son argument dans l'ordre
   inverse. Dans un premier temps, on pourra utiliser la fonction de
   concatÃ©nation vue prÃ©cÃ©demment. *)

(* RÃ‰SULTAT ATTENDU : cons 1 (cons 2 (cons 3 (cons 4 vide))) *)
(* Compute (miroir liste4).*)

(* RÃ‰SULTAT ATTENDU : cons 1 (cons 2 (cons 3 (cons 4 vide))) *)
(* Compute (miroir' liste4).*)


(* EXERCICE *)
(* Ã‰crire une fonction supprime: nat -> nliste -> nliste telle que
   supprime n l retourne une liste d'objets de type nat correspondant
   Ã  l sans la premiÃ¨re occurrence de n (le cas Ã©chÃ©ant), Ã  l
   sinon. *)

(* RÃ‰SULTAT ATTENDU : cons 4 (cons 2 (cons 1 vide)) *)
(* Compute (supprime 3 liste4). *)


(* EXERCICE *)
(* Ã‰crire une fonction supprime_tout: nat -> nliste -> nliste telle
   que supprime_tout n l retourne une liste correspondant Ã  l sans
   occurrence d'un nat n (le cas Ã©chÃ©ant), Ã  l sinon. *)


(* EXERCICE *)
(* Ã‰crire une fonction il_existe_pair: nliste -> booleens, telle que
   il_existe_pair l retourne Vrai si un Ã©lÃ©ment de l est pair, Faux
   sinon. *)

(* RÃ‰SULTAT ATTENDU : true *)
(* Compute (il_existe_pair liste4).*)


(* EXERCICE *)
(* Insertion triÃ©e *)
(* Ã‰crire dans un premier temps une fonction leq : nat -> nat -> bool qui teste si le
premier entier est infÃ©rieur ou Ã©gal au second *)

(* RÃ‰SULTAT ATTENDU : true *)
(* Compute (leq 2 2).*)

(* RÃ‰SULTAT ATTENDU : true *)
(* Compute (leq 2 3).*)

(* RÃ‰SULTAT ATTENDU : false *)
(* Compute (leq 3 2).*)

(* Ã‰crire une fonction insertion_triee : nat -> nliste -> nliste qui effectue
une insertion triÃ©e dans une liste *)

(* RÃ‰SULTAT ATTENDU : cons 1 (cons 2 (cons 2 (cons 3 (cons 4 vide)))) *)
(* Compute (insertion_triee 2 (miroir liste4)).*)

(* RÃ‰SULTAT ATTENDU : cons 4 (cons 3 (cons 2 (cons 1 (cons 6 vide)))) *)
(* Compute (insertion_triee 6 liste4).*)


(* EXERICE *)
(* Tri par insertion d'une liste *)
(* Ã‰crire une fonction tri_insertion : nliste -> nliste qui effectue
le tri par insertion d'une liste *)

(* RÃ‰SULTAT ATTENDU : cons 1 (cons 1 (cons 2 (cons 2 (cons 3 (cons 3 (cons 4 (cons 4 vide)))))) *)
(* Compute (tri_insertion (concat liste4 liste4)).*)






(* 3) ARBRES BINAIRES *)


(* Arbres binaires *)

(* EXERCICE *)
(* Donner une dÃ©finition par induction de l'ensemble nBin des arbres
binaires contenant des nat. On souhaite avoir une reprÃ©sentation de
l'arbre vide dans nBin. *)



(* Donner un exemple d'arbre, disons Ã  5 Ã©lÃ©ments *)

(*
Definition a1 := nNode
                      (nNode nEmpty 2 nEmpty)
                      1
                      (nNode
                            (nNode nEmpty 4 nEmpty)
                            3
                            (nNode nEmpty 5 nEmpty)
                      ).

Check a1.
Print a1.
*)

(* EXERCICE *)
(* DÃ©finir la fonction nelements qui renvoie la liste des Ã©lÃ©ments
   contenus dans un arbre binaire de nat. Le faire naÃ¯vement avec un
   concat pour commencer. *)

(* RÃ‰SULTAT ATTENDU : cons 1 (cons 2 (cons 3 (cons 4 (cons 5 vide)))) *)
(* Compute (nelements a1).*)



(* EXERCICE *)
(* DÃ©finir la fonction nnelts qui renvoie le nombre de noeuds internes
   (portant une Ã©tiquette de type nat) dans un nBin. *)

(* RÃ‰SULTAT ATTENDU : 5 *)
(* Compute (nnelts a1).*)


(* EXERCICE *)
(* DÃ©finir la fonction nfeuilles qui renvoie le nombre de feuilles *)

(* RÃ‰SULTAT ATTENDU : 6 *)
(* Compute nfeuilles a1. *)


(* EXERCICE *)
(* DÃ©finir la fonction nsum qui renvoie la somme des valeurs portÃ©es
   par les noeuds internes d'un nBin. *)

(* RÃ‰SULTAT ATTENDU : 15 *)
(* Compute (nsum a1).*)



(* ------------------------------------------------------------ *)